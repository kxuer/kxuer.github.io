(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{406:function(s,e,n){"use strict";n.r(e);var i=n(4),l=Object(i.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("访问硬件的过程：![[Pasted image 20230303095242.png]]")]),s._v(" "),e("ul",[e("li",[s._v("内核中的总线控制器驱动 驱动 I2C, SPI, USB, PCI控制器。")]),s._v(" "),e("li",[s._v("总线子系统为设备驱动提供了访问某种类型总线（I2C, SPI, PCI, USB等等）的API。")]),s._v(" "),e("li",[s._v("设备驱动 驱动 连接到某个总线的某个设备。")]),s._v(" "),e("li",[s._v("驱动子系统通过kernel/user-space接口对外提供访问设备的方法。")]),s._v(" "),e("li",[s._v("应用程序通过kernel/user-space接口或库访问设备。\n示例：GPIO扩展器![[Pasted image 20230303100540.png]]")])]),s._v(" "),e("p",[s._v("kernel/user-space接口：")]),s._v(" "),e("ul",[e("li",[s._v("同类型的设备（如GPIO控制器）暴露的是统一的kernel/user-space接口。")]),s._v(" "),e("li",[s._v("用户空间程序不必知道GPIO控制器的细节，只需关心接口是否合法即可。")]),s._v(" "),e("li",[s._v("有些可用的开源库封装了这些kernel/user-space接口，用户空间程序使用库的接口即可。\n用于设备的内核子系统：")]),s._v(" "),e("li",[s._v("用于以太网、WiFi、CAN、802.15.4的网络协议栈。")]),s._v(" "),e("li",[s._v("GPIO。")]),s._v(" "),e("li",[s._v("用于摄像机、视频编解码的Video4Linux。")]),s._v(" "),e("li",[s._v("用于图形控制器、GPU的DRM。")]),s._v(" "),e("li",[s._v("用于音频的ALSA。")]),s._v(" "),e("li",[s._v("用于ADC, DAC，陀螺仪，传感器等设备的IIO。")]),s._v(" "),e("li",[s._v("用于闪存的MTD。")]),s._v(" "),e("li",[s._v("PWM。")]),s._v(" "),e("li",[s._v("用于键盘、鼠标、触摸屏、操纵杆的输入系统。")]),s._v(" "),e("li",[s._v("看门狗。")]),s._v(" "),e("li",[s._v("用于实时时钟的RTC。")]),s._v(" "),e("li",[s._v("用于辅助处理器的remoteproc。")]),s._v(" "),e("li",[s._v("用于密码加速器的crypto。")]),s._v(" "),e("li",[s._v("用于硬件监控的hwmon。")]),s._v(" "),e("li",[s._v("用于块存储设备的block layer。")]),s._v(" "),e("li",[s._v("......")])]),s._v(" "),e("blockquote",[e("p",[s._v("从用户空间之间访问设备：最好通过位于内核的设备驱动访问设备，但是可能有些设备并不适配到任何已存在的内核子系统。根据总线不同，内核提供了以下机制：")]),s._v(" "),e("ul",[e("li",[s._v("I2C: "),e("a",{attrs:{href:"https://docs.kernel.org/i2c/dev-interface.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("i2c-dev"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("SPI: "),e("a",{attrs:{href:"https://docs.kernel.org/spi/spidev.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("spidev"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("内存映射："),e("a",{attrs:{href:"https://docs.kernel.org/driver-api/uio-howto.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("UIO"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("USB: /dev/bus/usb, 通过 "),e("a",{attrs:{href:"https://libusb.info/",target:"_blank",rel:"noopener noreferrer"}},[s._v("libusb"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("PCI: "),e("a",{attrs:{href:"https://docs.kernel.org/PCI/sysfs-pci.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("sysfs entries for PC"),e("OutboundLink")],1),s._v("\n示例：GPIO![[Pasted image 20230303223656.png]]")])]),s._v(" "),e("p",[s._v("如果写的是用户空间驱动而不是内核驱动，有什么问题？")]),s._v(" "),e("ul",[e("li",[s._v("其他内核驱动无法使用你写的用户空间驱动，导致无法正常工作。")])]),s._v(" "),e("p",[s._v("Upstream drivers vs. out-of-tree drivers")]),s._v(" "),e("ul",[e("li",[s._v("简单理解：Upstream drivers指内核官方认可的驱动，out-of-tree drivers是设备厂商提供的驱动。")])]),s._v(" "),e("p",[s._v("如何查找内核驱动：")]),s._v(" "),e("ul",[e("li",[s._v("grep：如果是I2C、 SPI、内核映射设备，则根据设备名或厂商搜索；如果是USB、PCI，则根据厂商ID、产品ID搜索。")]),s._v(" "),e("li",[s._v("注意：驱动文件名不仅仅反应支持一个设备，而可能是某一类设备。")]),s._v(" "),e("li",[s._v("示例：查找在I2C总线上的Maxim Integrated MAX7313 GPIO控制器的驱动\n"),e("ul",[e("li",[s._v("git grep -i max7313")]),s._v(" "),e("li",[s._v("查看drivers/gpio/Makefile哪个内核选项启动该驱动")])])])])]),s._v(" "),e("p",[s._v("用于硬件设备的用户空间接口：")]),s._v(" "),e("ul",[e("li",[s._v("从上层角度看，内核暴露的用于访问硬件设备的三种接口：  ^5db532\n"),e("ol",[e("li",[s._v("/dev目录下的设备节点。\n"),e("ul",[e("li",[s._v("主要分为：\n"),e("ul",[e("li",[s._v("字符设备：无限制的字节流。用于串口、终端、声卡、视频获取设备、帧缓冲等等。")]),s._v(" "),e("li",[s._v("块设备：用固定大小的块来读写数据。用于硬盘、USB设备、SD卡等等。")])])]),s._v(" "),e("li",[s._v("标识方法：Type（字符设备或块设备）+Major（通常为设备类别）+Minor（通常为设备ID）。"),e("a",{attrs:{href:"https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/devices.txt",target:"_blank",rel:"noopener noreferrer"}},[s._v("官方保留、不可用的数字"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("抽象：每个设备都是一个文件，可通过文件API操作。")]),s._v(" "),e("li",[s._v("如何创建设备文件：\n"),e("ul",[e("li",[s._v("Linux 2.6.32之前："),e("code",[s._v("mknod /dev/<device> [c|b] major minor")])]),s._v(" "),e("li",[s._v("将devtmpfs虚拟文件系统挂载到/dev目录下 → 内核自动创建和删除设备文件。使用CONFIG_DEVTMPFS_MOUNT设置内核在启动时挂载devtmpfs虚拟文件系统（使用initramfs时不可用）。该方式还不够强大，可使用udev和mdev作为补充。")]),s._v(" "),e("li",[s._v("udev：一个从内核接收有关设备出现/消失事件的damon程序。\n"),e("ul",[e("li",[s._v("可以创建/删除设备文件（现在通常由devtmpfs做这事），修改权限、所属关系，[[06 内核驱动#^886d86]]自动加载内核模块，创建到设备的符号链接。根据/lib/udev/rules.d 和 /etc/udev/rules.d中的规则文件执行。")])])]),s._v(" "),e("li",[s._v("mdev：Busybox实现的轻量级udev。")])])]),s._v(" "),e("li",[s._v("示例：\n"),e("ul",[e("li",[s._v("串口：/dev/ttyS*, /dev/ttyUSB*, /dev/ttyACM*, etc.")]),s._v(" "),e("li",[s._v("GPIO控制器：/dev/gpiochipX。")]),s._v(" "),e("li",[s._v("块存储设备：/dev/sd*, /dev/mmcblk*, /dev/nvme*")]),s._v(" "),e("li",[s._v("闪存设备：/dev/mtd*")]),s._v(" "),e("li",[s._v("显示设备和GPU：/dev/dri/*")]),s._v(" "),e("li",[s._v("声音设备：/dev/snd/*")]),s._v(" "),e("li",[s._v("摄像机设备：/dev/video*")]),s._v(" "),e("li",[s._v("看门狗设备：/dev/watchdog*")]),s._v(" "),e("li",[s._v("输入设备：/dev/input/*")])])])])]),s._v(" "),e("li",[s._v("sysfs文件系统中的项。\n"),e("ul",[e("li",[s._v("block/：symlinks到/sys/devices中的块设备。")]),s._v(" "),e("li",[s._v("bus/：每种总线都有各自一个子文件夹。\n"),e("ul",[e("li",[s._v("例/sys/bus/i2c/drivers：连接到I2C总线的设备的设备驱动。")]),s._v(" "),e("li",[s._v("例/sys/bus/i2c/devices：连接到I2C总线的所有设备。")])])]),s._v(" "),e("li",[s._v("class/：每种类别的设备都有各自一个子文件夹，如input, leds, pwm, etc.")]),s._v(" "),e("li",[s._v("dev/：\n"),e("ul",[e("li",[s._v("block/：每个块设备的symlink, named after major/minor。")]),s._v(" "),e("li",[s._v("char/：每个字符设备的symlink, named after major/minor。")])])]),s._v(" "),e("li",[s._v("devices/：系统中的所有设备，看"),e("a",{attrs:{href:"https://lwn.net/Articles/646617/",target:"_blank",rel:"noopener noreferrer"}},[s._v("这个"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("firmware/：固件数据。\n"),e("ul",[e("li",[s._v("devicetree/：设备树节点和属性。")])])]),s._v(" "),e("li",[s._v("fs/：与文件系统驱动相关的属性。")]),s._v(" "),e("li",[s._v("kernel/：与内核子系统相关的属性。")]),s._v(" "),e("li",[s._v("module/：与内核模块相关的属性。")]),s._v(" "),e("li",[s._v("power/：与电源管理相关的属性。")])])])])])]),s._v(" "),e("blockquote",[e("p",[s._v("注：所有的设备都可在sysfs中能看到，不管它们是否在/dev有接口。")]),s._v(" "),e("ul",[e("li",[s._v("通常用/dev访问设备。")]),s._v(" "),e("li",[s._v("/sys更多的是用来查看设备的属性。")]),s._v(" "),e("li",[s._v("有些设备只在/sys出现：\n"),e("ul",[e("li",[s._v("• LED: /sys/class/leds")]),s._v(" "),e("li",[s._v("• PWM: /sys/class/pwm")]),s._v(" "),e("li",[s._v("• IIO: /sys/class/iio\nGPIO (General Purpose Input Output)：")]),s._v(" "),e("li",[s._v("以前用/sys/class/gpios接口访问。")]),s._v(" "),e("li",[s._v("现在用"),e("a",{attrs:{href:"https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/",target:"_blank",rel:"noopener noreferrer"}},[s._v("libgpiod"),e("OutboundLink")],1),s._v("：\n"),e("ul",[e("li",[s._v("其基于/dev/gpiochipx字符设备。")]),s._v(" "),e("li",[s._v("是个C语言库。也提供了命令行工具：gpiodetect, gpioset, gpioget...\n其他的虚拟文件系统：")])])]),s._v(" "),e("li",[s._v("debugfs：挂载在/sys/kernel/debug，包含许多来自内核的debug信息（包括设备相关的）；/sys/kernel/debug/pinctrl是pin多路复用的debug信息，/sys/kernel/debug/gpio是GPIO的debug信息，/sys/kernel/debug/pwm是PWM的debug信息。")]),s._v(" "),e("li",[s._v("configfs：挂载在/sys/kernel/config，用来内核高级机制的配置管理，如USB gadget的配置。")])])])])]),s._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[s._v("网络套接字及相关API。")])]),s._v(" "),e("p",[s._v("使用内核模块：")]),s._v(" "),e("ul",[e("li",[s._v("为什么要用模块：保证内核镜像最小化，模块只有在检测到硬件时才按需加载；方便驱动开发；减少启动时间。![[Pasted image 20230304174340.png]]")]),s._v(" "),e("li",[s._v("模块安装：\n"),e("ul",[e("li",[s._v("在"),e("code",[s._v("/lib/modules/<kernel-version>/")]),s._v("目录下。")]),s._v(" "),e("li",[s._v("编译后的内核模块存储在.ko文件。")]),s._v(" "),e("li",[s._v("元数据文件：\n"),e("ul",[e("li",[s._v("modules.dep模块依赖：模块加载工具会使用这些信息加载模块。")]),s._v(" "),e("li",[s._v("modules.alias"),e("strong",[s._v("模块别名")]),s._v("：设备属性映射模块名，方便查找模块名。![[Pasted image 20230304175704.png]] ^886d86")]),s._v(" "),e("li",[s._v("modules.symbols，modules.builtin。")])])]),s._v(" "),e("li",[s._v("每个文件都有对应的.bin文件，它是文本文件的优化版本。")])])]),s._v(" "),e("li",[s._v("模块工具：\n"),e("ul",[e("li",[s._v("modinfo："),e("code",[s._v("modinfo <module_name>")]),s._v("显示/lib/modules目录下模块的信息；或"),e("code",[s._v("modinfo /path/to/module.ko")])]),s._v(" "),e("li",[s._v("lsmod：显示当前已加载的内核模块，是通过/proc/modules获取的信息。")]),s._v(" "),e("li",[s._v("insmod、rmmod：加载、卸载模块，必须使用完整路径名，并不会处理模块依赖。")]),s._v(" "),e("li",[s._v("modprobe：加载、卸载模块，使用模块名作为参数即可，使用modules.dep文件自动处理模块依赖，"),e("code",[s._v("modprobe -r <module_name>")]),s._v("卸载模块时还可以把没有被用到的依赖模块一并卸载。")]),s._v(" "),e("li",[s._v("模块配置参数：\n"),e("ul",[e("li",[s._v("安装模块时设置：insmod ./usb-storage.ko delay_use=0")]),s._v(" "),e("li",[s._v("使用配置文件：/etc/modprobe.conf文件或/etc/modprobe.d/目录下的文件，例"),e("code",[s._v("options usb-storage delay_use=0")]),s._v("。")]),s._v(" "),e("li",[s._v("当模块内建到内核中时，也可以使用内核命令行：usb-storage.delay_use=0")])])])])]),s._v(" "),e("li",[s._v("sysfs文件系统中的模块信息："),e("code",[s._v("/sys/module/<module_name>")]),s._v(" "),e("ul",[e("li",[s._v("（个人理解）包含当前系统已加载的模块信息。")]),s._v(" "),e("li",[s._v("甚至可以在运行时改变模块参数（取决于模块代码）："),e("code",[s._v("echo 0 > /sys/module/usb_storage/parameters/delay_use")])])])])]),s._v(" "),e("p",[s._v("描述不可发现的硬件："),e("strong",[s._v("设备树")])]),s._v(" "),e("ul",[e("li",[s._v("描述不可发现的硬件的方法：\n"),e("ul",[e("li",[s._v("直接在OS/bootloader代码中：使用编译好的数据结构，可维护性较差。")]),s._v(" "),e("li",[s._v("使用ACPI表：多用在x86平台，有些ARM64平台也用；表由固件提供。")]),s._v(" "),e("li",[s._v("使用设备树：起源于由Sun设计、用于SPARC和PowerPC的OpenFirmware。目前主要用在嵌入式设备。")])])]),s._v(" "),e("li",[s._v("设备树源文件（树形数据结构）经过设备树编译器编译后生成Device Tree Blob。\n"),e("ul",[e("li",[s._v("DTB加载到内存后也叫FDT, Flattened Device Tree")]),s._v(" "),e("li",[s._v("U-Boot中：使用fdt命令。")]),s._v(" "),e("li",[s._v("fdt_ APIs。")])])]),s._v(" "),e("li",[s._v("使用blob：\n"),e("ul",[e("li",[s._v("可以在bootloader中被直接链接。")]),s._v(" "),e("li",[e("code",[s._v("boot[z,i,m] <kernel-addr> - <dtb-addr>")]),s._v("![[Pasted image 20230304214010.png]]")]),s._v(" "),e("li",[s._v("可以使用libfdt库解析blob。")])])]),s._v(" "),e("li",[s._v("设备树源文件：\n"),e("ul",[e("li",[s._v("位于内核源码"),e("code",[s._v("arch/<ARCH>/boot/dts")]),s._v("，Linux 6.0中大概由4500个.dts 和 .dtsi文件。")]),s._v(" "),e("li",[s._v("这些文件也被复制到其他项目，如U-Boot, Barebox, TF-A中。")])])]),s._v(" "),e("li",[s._v("设备树基本语法：![[Pasted image 20230304215152.png]]\n"),e("ul",[e("li",[s._v("树由节点组成，节点≈一个设备或IP块。")]),s._v(" "),e("li",[s._v("节点包含属性，属性≈设备特征。\n"),e("ul",[e("li",[s._v("compatible：值为字符串列表，从特殊到一般。![[Pasted image 20230305165644.png]]\n"),e("ul",[e("li",[s._v("唯一指定了设备的编程模型。")]),s._v(" "),e("li",[s._v("通常被操作系统用来查找适合设备的驱动。\n"),e("ul",[e("li",[s._v("平台设备（platform devices）：顶层设备树节点、simple-bus的子节点。在内核启动时，会自动初始化平台设备。")]),s._v(" "),e("li",[s._v("每个Linux驱动都有一张其支持的compatible strings的列表："),e("code",[s._v("struct of_device_id[]")]),e("a",{attrs:{href:"https://elixir.bootlin.com/linux/latest/ident/of_device_id",target:"_blank",rel:"noopener noreferrer"}},[s._v("of_device_id"),e("OutboundLink")],1)]),s._v(" "),e("li",[s._v("当一个设备树节点的compatible string匹配某个驱动时，设备将被绑定到该驱动上。")]),s._v(" "),e("li",[s._v("![[Pasted image 20230305165810.png]]")])])]),s._v(" "),e("li",[s._v("每个字符串的格式为：“vendor,model”")]),s._v(" "),e("li",[s._v("特殊值：simple-bus → 所有子节点都是内存映射（memory-mapped）设备的总线。")])])]),s._v(" "),e("li",[s._v("reg：\n"),e("ul",[e("li",[s._v("如果是内存映射设备：每个项为内存映射寄存器的基物理地址,大小。")]),s._v(" "),e("li",[s._v("如果是I2C设备：值为设备在I2C总线上的地址。")]),s._v(" "),e("li",[s._v("如果是SPI设备：值为芯片选择数。")]),s._v(" "),e("li",[s._v("The unit address must be the address of the first reg entry.")])])]),s._v(" "),e("li",[s._v("status：描述设备是否被使用。")])])]),s._v(" "),e("li",[s._v("phandle：指向其他节点。")])])]),s._v(" "),e("li",[s._v("设备树示例：![[Pasted image 20230304220529.png]]")])]),s._v(" "),e("div",{staticClass:"language-dts line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('/ {\n    #address-cells = <1>;\n    #size-cells = <1>;\n    model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";\n    compatible = "st,stm32mp157c-dk2", "st,stm32mp157";\n\n    cpus {  #CPU核心\n        #address-cells = <1>;\n        #size-cells = <0>;\n        cpu0: cpu@0 {\n\t        compatible = "arm,cortex-a7";\n\t        clock-frequency = <650000000>;\n\t        device_type = "cpu";\n\t        reg = <0>;\n        };\n\n        cpu1: cpu@1 {\n\t        compatible = "arm,cortex-a7";\n\t        clock-frequency = <650000000>;\n\t        device_type = "cpu";\n\t        reg = <1>;\n        };\n    };\n\n    memory@0 {  #内存\n        device_type = "memory";\n        reg = <0x0 0x20000000>;\n    };\n\n    chosen {\n        bootargs = "";\n        stdout-path = "serial0:115200n8";\n    };\n\n    intc: interrupt-controller@a0021000 {   #GIC中断控制器\n        compatible = "arm,cortex-a7-gic";\n        #interrupt-cells = <3>;\n        interrupt-controller;\n        reg = <0xa0021000 0x1000>,\n        <0xa0022000 0x2000>;\n    };\n\n    soc {\n        compatible = "simple-bus";\n        #address-cells = <1>;\n        #size-cells = <1>;\n        interrupt-parent = <&intc>; # 中断控制的父控制  \n\n        i2c1: i2c@40012000 {    #I2C控制器\n            compatible = "st,stm32mp15-i2c";\n            reg = <0x40012000 0x400>;\n            interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,\n\t\t\t             <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;\n            #address-cells = <1>;\n            #size-cells = <0>;\n            status = "okay";  \n\n            cs42l51: cs42l51@4a {   #音频解码器\n                compatible = "cirrus,cs42l51";\n                reg = <0x4a>;\n                reset-gpios = <&gpiog 9 GPIO_ACTIVE_LOW>;\n                status = "okay";\n            };\n        };\n\n        ethernet0: ethernet@5800a000 {  #以太网\n            compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";\n            reg = <0x5800a000 0x2000>;\n            interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;\n            status = "okay";\n\n            mdio0 {\n                #address-cells = <1>;\n                #size-cells = <0>;\n                compatible = "snps,dwmac-mdio";\n                phy0: ethernet-phy@0 {\n                    reg = <0>;\n                };\n            };            \n        };\n    };\n};\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br"),e("span",{staticClass:"line-number"},[s._v("44")]),e("br"),e("span",{staticClass:"line-number"},[s._v("45")]),e("br"),e("span",{staticClass:"line-number"},[s._v("46")]),e("br"),e("span",{staticClass:"line-number"},[s._v("47")]),e("br"),e("span",{staticClass:"line-number"},[s._v("48")]),e("br"),e("span",{staticClass:"line-number"},[s._v("49")]),e("br"),e("span",{staticClass:"line-number"},[s._v("50")]),e("br"),e("span",{staticClass:"line-number"},[s._v("51")]),e("br"),e("span",{staticClass:"line-number"},[s._v("52")]),e("br"),e("span",{staticClass:"line-number"},[s._v("53")]),e("br"),e("span",{staticClass:"line-number"},[s._v("54")]),e("br"),e("span",{staticClass:"line-number"},[s._v("55")]),e("br"),e("span",{staticClass:"line-number"},[s._v("56")]),e("br"),e("span",{staticClass:"line-number"},[s._v("57")]),e("br"),e("span",{staticClass:"line-number"},[s._v("58")]),e("br"),e("span",{staticClass:"line-number"},[s._v("59")]),e("br"),e("span",{staticClass:"line-number"},[s._v("60")]),e("br"),e("span",{staticClass:"line-number"},[s._v("61")]),e("br"),e("span",{staticClass:"line-number"},[s._v("62")]),e("br"),e("span",{staticClass:"line-number"},[s._v("63")]),e("br"),e("span",{staticClass:"line-number"},[s._v("64")]),e("br"),e("span",{staticClass:"line-number"},[s._v("65")]),e("br"),e("span",{staticClass:"line-number"},[s._v("66")]),e("br"),e("span",{staticClass:"line-number"},[s._v("67")]),e("br"),e("span",{staticClass:"line-number"},[s._v("68")]),e("br"),e("span",{staticClass:"line-number"},[s._v("69")]),e("br"),e("span",{staticClass:"line-number"},[s._v("70")]),e("br"),e("span",{staticClass:"line-number"},[s._v("71")]),e("br"),e("span",{staticClass:"line-number"},[s._v("72")]),e("br"),e("span",{staticClass:"line-number"},[s._v("73")]),e("br"),e("span",{staticClass:"line-number"},[s._v("74")]),e("br"),e("span",{staticClass:"line-number"},[s._v("75")]),e("br"),e("span",{staticClass:"line-number"},[s._v("76")]),e("br"),e("span",{staticClass:"line-number"},[s._v("77")]),e("br"),e("span",{staticClass:"line-number"},[s._v("78")]),e("br"),e("span",{staticClass:"line-number"},[s._v("79")]),e("br"),e("span",{staticClass:"line-number"},[s._v("80")]),e("br"),e("span",{staticClass:"line-number"},[s._v("81")]),e("br"),e("span",{staticClass:"line-number"},[s._v("82")]),e("br")])]),e("ul",[e("li",[s._v("设备树继承：\n"),e("ul",[e("li",[s._v(".dtsi是被包含的文件：通常包含SoC级别的定义信息、对多个开发板都公用的定义信息。")]),s._v(" "),e("li",[s._v(".dts是最终的设备树文件：通常包含开发板级别的定义信息。")]),s._v(" "),e("li",[s._v("通过堆叠（overlaying）方式工作。")]),s._v(" "),e("li",[s._v("示例：STM32MP1![[Pasted image 20230305142446.png]]")])])]),s._v(" "),e("li",[s._v("设备树设计原则：\n"),e("ul",[e("li",[s._v("用于描述，而不是配置。")]),s._v(" "),e("li",[s._v("与操作系统无关：无论是U-Boot, FreeBSD或者Linux。且升级系统时不用更改设备树。")]),s._v(" "),e("li",[s._v("描述的是设备组件的集成，而不是设备组件的内部构造：设备树描述设备是如何连接/集成（如通过IRQ总线、DMA通道、时钟、重置线等等）到系统的其他部分，而设备如何工作是由设备驱动中的代码决定的。")])])]),s._v(" "),e("li",[s._v("设备树规范："),e("a",{attrs:{href:"https://www.devicetree.org/specifications/",target:"_blank",rel:"noopener noreferrer"}},[s._v("specifications"),e("OutboundLink")],1),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://elixir.bootlin.com/linux/latest/source/Documentation/devicetree/bindings/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Device Tree Bindings"),e("OutboundLink")],1),s._v(" → 关于设备的每一部分是如何描述的文档。\n"),e("ul",[e("li",[s._v("以前是human readable文档。")]),s._v(" "),e("li",[s._v("现在使用YAML格式的文档。")])])])])]),s._v(" "),e("li",[s._v("校验设备树：\n"),e("ul",[e("li",[s._v("dtc只做语法校验。")]),s._v(" "),e("li",[s._v("校验YAML bindings：make dt_binding_check")]),s._v(" "),e("li",[s._v("校验当前启用的设备树是否与YAML bindings一致：make dtbs_check")]),s._v(" "),e("li",[s._v("校验YAML binding指定的设备树：make DT_SCHEMA_FILES=Documentation/devicetree/bindings/trivialdevices.yaml dtbs_check")])])]),s._v(" "),e("li",[s._v("把这些描述为资源：interrupts, clocks, DMA, reset lines, ...\n"),e("ul",[e("li",[s._v("pin多路复用：使用pinmux控制器，设备树描述哪些配置可用、根据pin的状态设置设备使用的配置（pinctrl-X）。![[Pasted image 20230305173225.png]]")])])]),s._v(" "),e("li",[s._v("示例：LED和I2C设备\n"),e("ul",[e("li",[s._v("创建arch/arm/boot/dts/stm32mp157a-dk1-custom.dts：")])]),s._v(" "),e("div",{staticClass:"language-dts line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('#include "stm32mp157a-dk1.dts" \n/ { \n    leds { //描述LED\n   \t compatible = "gpio-leds"; \n   \t webinar { \n   \t\t label = "webinar"; \n   \t\t gpios = <&gpioe 1 GPIO_ACTIVE_HIGH>; \n   \t}; \n   }; \n   &i2c5 { //连接I2C温度、湿度、压力传感器\n   \tstatus = "okay"; \n   \tclock-frequency = <100000>; \n   \tpinctrl-names = "default", "sleep"; \n   \tpinctrl-0 = <&i2c5_pins_a>; \n   \tpinctrl-1 = <&i2c5_pins_sleep_a>; \n   \tpressure@76 { \n   \t\tcompatible = "bosch,bme280"; \n   \t\treg = <0x76>; \n   \t}; \n   };\n};\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br")])]),e("ul",[e("li",[s._v("修改arch/arm/boot/dts/Makefile使stm32mp157a-dk1-custom.dts编译到一个DTB。")]),s._v(" "),e("li",[s._v("制作dtbs：DTC arch/arm/boot/dts/stm32mp157a-dk1-custom.dtb")])]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("255")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" /sys/class/leds/webinar/brightness   "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#让led亮起来")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" /sys/bus/iio/devices/iio"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),s._v(":device2/in_humidityrelative_input  "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#读取湿度值")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" /sys/bus/iio/devices/iio"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),s._v(":device2/in_pressure_input   "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#读取压力值")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" /sys/bus/iio/devices/iio"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),s._v(":device2/in_temp_input   "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#读取温度值")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])])])]),s._v(" "),e("p",[s._v("可发现的设备：USB和PCI")]),s._v(" "),e("ul",[e("li",[s._v("一些总线有内建的硬件发现机制，主要是USB和PCI总线。\n"),e("ul",[e("li",[s._v("总线上的硬件设备可被枚举，设备特性也可通过驱动或总线控制器获得。")]),s._v(" "),e("li",[s._v("lsusb，lspci：列举检测到的设备，但能被检测到并不意味着存在设备对应的内核驱动。")]),s._v(" "),e("li",[s._v("如何关联内核驱动：通常根据设备ID、厂商ID，或者根据设备类型、子类型等设备特性。")])])])])])}),[],!1,null,null,null);e.default=l.exports}}]);