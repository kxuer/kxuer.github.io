(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{410:function(e,v,_){"use strict";_.r(v);var l=_(4),i=Object(l.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("与桌面Linux应用开发类似。")]),e._v(" "),v("p",[e._v("例：使用Meson构建系统")]),e._v(" "),v("ul",[v("li",[e._v("配置选项：meson_options.txt")])]),e._v(" "),v("div",{staticClass:"language-txt line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-txt"}},[v("code",[e._v("option('demo-debug', type : 'feature', value : 'disabled')\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("meson.build")])]),e._v(" "),v("div",{staticClass:"language-build line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("project('tutorial', 'c') \n\ndemo_c_args = [] \nif get_option('demo-debug').enabled() \n\tdemo_c_args += '-DDEBUG' \nendif \n\ngtkdep = dependency('gtk+-3.0')\n\nexecutable('demo', 'main.c', c_args: demo_c_args, dependencies : gtkdep) #c_args配置参数；dependencies设置依赖项（用pkg-config搜索）；\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br"),v("span",{staticClass:"line-number"},[e._v("7")]),v("br"),v("span",{staticClass:"line-number"},[e._v("8")]),v("br"),v("span",{staticClass:"line-number"},[e._v("9")]),v("br"),v("span",{staticClass:"line-number"},[e._v("10")]),v("br")])]),v("p",[e._v("Debugging")]),e._v(" "),v("ul",[v("li",[e._v("GDB：\n"),v("ul",[v("li",[e._v("支持语言：C, C++, Pascal, Objective-C, Fortran, Ada...")]),e._v(" "),v("li",[e._v("提供命令行接口。")]),e._v(" "),v("li",[e._v("集成到了许多IDE中。")]),e._v(" "),v("li",[e._v("能够用来：\n"),v("ul",[v("li",[e._v("控制正在运行的程序的执行，设置断点、修改内部变量。")]),e._v(" "),v("li",[e._v("当应用崩溃时查看其在做什么。")])])]),e._v(" "),v("li",[e._v("另一个选择：来自LLVM的lldb。")]),e._v(" "),v("li",[e._v("启动：\n"),v("ul",[v("li",[e._v("主要用来debug一个进程，使用gdb启动进程："),v("code",[e._v("gdb <program>")])]),e._v(" "),v("li",[e._v("gdb也可以附着到一个正在运行的进程："),v("code",[e._v("gdb -p <pid>")])])])]),e._v(" "),v("li",[e._v("使用：\n"),v("ul",[v("li",[e._v("使用gdb启动进程时，还需要执行run命令，程序才会运行。")]),e._v(" "),v("li",[e._v("break foobar (b)：在函数foobar()的入口设置断点。")]),e._v(" "),v("li",[e._v("break foobar.c:42")]),e._v(" "),v("li",[v("code",[e._v("print var, print $reg or print task->files[0].fd (p)")]),e._v("：打印变量var的值，打印寄存器$reg的值，打印结构体中的值。")]),e._v(" "),v("li",[e._v("info registers：显示架构寄存器。")]),e._v(" "),v("li",[e._v("continue (c)：在断点之后继续执行。")]),e._v(" "),v("li",[e._v("next (n)：执行下一行代码，跳过函数调用。")]),e._v(" "),v("li",[e._v("step (s)：执行下一行代码，进入子函数。")]),e._v(" "),v("li",[e._v("stepi (si)：执行下一条指令。")]),e._v(" "),v("li",[e._v("finish：执行到函数返回。")]),e._v(" "),v("li",[e._v("backtrace (bt)：显示程序执行栈。")])])])])]),e._v(" "),v("li",[e._v("远程debug：\n"),v("ul",[v("li",[e._v("gdb可以直接访问 编译时带有debugging符号 的二进制和库。")]),e._v(" "),v("li",[e._v("但是，有的嵌入式环境资源受限，无法直接用gdb进行debugging（x86平台上占用2.4MB）。")]),e._v(" "),v("li",[e._v("远程debug：![[Pasted image 20230307174545.png]]\n"),v("ul",[v("li",[e._v("ARCH-linux-gdb用在主机，包含gdb的所有特性。")]),e._v(" "),v("li",[e._v("gdbserver用在目标板上（arm平台上占用400KB）。")]),e._v(" "),v("li",[e._v("架构：![[Pasted image 20230307174710.png]]")]),e._v(" "),v("li",[e._v("在目标板上：\n"),v("ul",[v("li",[e._v("通过gdbserver运行程序（此时程序不会立即启动）：\n"),v("ul",[v("li",[v("code",[e._v("gdbserver localhost:<port> <executable> <args>")])]),e._v(" "),v("li",[v("code",[e._v("gdbserver /dev/ttyS0 <executable> <args>")])])])]),e._v(" "),v("li",[e._v("或者附着到一个正在运行的进程："),v("code",[e._v("gdbserver --attach localhost:<port> <pid>")])])])]),e._v(" "),v("li",[e._v("在主机上：\n"),v("ul",[v("li",[e._v("执行"),v("code",[e._v("ARCH-linux-gdb <executable>")])]),e._v(" "),v("li",[e._v("告诉gdb共享库在哪："),v("code",[e._v("gdb> set sysroot <library-path>")]),e._v("(without lib/)")]),e._v(" "),v("li",[e._v("连接到目标板：\n"),v("ul",[v("li",[v("code",[e._v("gdb> target remote <ip-addr>:<port>")]),e._v("（通过网络连接的）")]),e._v(" "),v("li",[v("code",[e._v("gdb> target remote /dev/ttyUSB0")]),e._v("（通过串口连接的）")])])])])])])])])]),e._v(" "),v("li",[e._v("Coredumps：\n"),v("ul",[v("li",[e._v("当应用因为段错误而崩溃时，应用就不再受debugger控制，此时无法通过debugger获取关于崩溃的信息。")]),e._v(" "),v("li",[e._v("幸运的是，Linux会生成 一个包含崩溃时应用内存的镜像 的core文件，gdb能够读取该文件。")]),e._v(" "),v("li",[e._v("在目标板上：\n"),v("ul",[v("li",[e._v("在shell中执行"),v("code",[e._v("ulimit -c unlimited")]),e._v("来启动当崩溃时生成core文件的功能。")]),e._v(" "),v("li",[e._v("（可选）修改core文件的文件名：/proc/sys/kernel/core_pattern")])])]),e._v(" "),v("li",[e._v("在主机上：崩溃后，把目标板的core文件转移到主机，然后运行"),v("code",[e._v("ARCH-linux-gdb -c core-file application-binary")]),e._v("。")])])])]),e._v(" "),v("p",[e._v("跟踪和分析")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("strace")]),e._v(":\n"),v("ul",[v("li",[e._v("是个"),v("em",[e._v("系统调用")]),e._v("追踪器。允许查看你的进程在干嘛：访问文件、分配内存......")]),e._v(" "),v("li",[v("code",[e._v("strace <command>")]),e._v("：启动进程，并追踪。")]),e._v(" "),v("li",[v("code",[e._v("strace -f <command>")]),e._v("：启动进程，并追踪，同时追踪子进程。")]),e._v(" "),v("li",[v("code",[e._v("strace -p <pid>")]),e._v("：追踪已有进程。 ^57b52c")]),e._v(" "),v("li",[v("code",[e._v("strace -c <command>")]),e._v("：每个系统调用的时间统计。")])])]),e._v(" "),v("li",[e._v("ltrace：一个用来追踪程序使用的"),v("em",[e._v("共享库调用")]),e._v("以及其接收到的所有信号。\n"),v("ul",[v("li",[e._v("没有共享库源码也能工作。")]),e._v(" "),v("li",[e._v("允许通过正则表达式过滤库调用。")]),e._v(" "),v("li",[e._v("同时显示系统调用：加-S选项。提供归总：加-c选项。")]),e._v(" "),v("li",[e._v("跟glibc一起工作最佳，因为其之前与uClibc工作时老崩溃。")])])]),e._v(" "),v("li",[e._v("ftrace：在内核里的追踪功能。\n"),v("ul",[v("li",[e._v("能够追踪：\n"),v("ul",[v("li",[e._v("预先在内核定义好的追踪位置，也叫追踪点，如调度、中断打断。")]),e._v(" "),v("li",[e._v("内核的任何函数。")]),e._v(" "),v("li",[e._v("用户空间程序的任何函数。")])])]),e._v(" "),v("li",[e._v("通过tracefs文件系统使用它。")]),e._v(" "),v("li",[e._v("trace-cmd是更高层的客户端工具，其使用了ftrace。")]),e._v(" "),v("li",[e._v("可被用来理解整体的系统活动，以及缩小指定的性能问题。")]),e._v(" "),v("li",[e._v("kernelshark：ftrace的可视化工具。")])])]),e._v(" "),v("li",[e._v("perf：instrument CPU performance counters, tracepoints, kprobes, and uprobes\n"),v("ul",[v("li",[e._v("直接被包含在Linux内核源码中："),v("a",{attrs:{href:"https://elixir.bootlin.com/linux/latest/source/tools/perf",target:"_blank",rel:"noopener noreferrer"}},[e._v("tools/perf"),v("OutboundLink")],1)]),e._v(" "),v("li",[e._v("支持多种可评估的事件：硬件事件（周期计数、L1缓存命中/未命中、页错误），软件事件（追踪点）。")]),e._v(" "),v("li",[e._v("例子：\n"),v("ul",[v("li",[e._v("perf list：列出所有当前已经事件。")]),e._v(" "),v("li",[v("code",[e._v("perf list 'sched:*'")]),e._v("：列出调度器追踪点。")]),e._v(" "),v("li",[v("code",[e._v("perf stat <command>")]),e._v("：某个命令的CPU计数统计。 ^ed01f8")]),e._v(" "),v("li",[e._v("perf stat -a sleep 5：整个系统5秒内的CPU计数统计。")]),e._v(" "),v("li",[v("code",[e._v("perf record -F 99 <command>")]),e._v("：性能分析。")]),e._v(" "),v("li",[e._v("perf record -e sched:sched_switch -a：通过调度器追踪点追踪所有的环境切换。")])])]),e._v(" "),v("li",[e._v("perf GUI: hotspot，用来做性能分析")])])]),e._v(" "),v("li",[e._v("gprof：\n"),v("ul",[v("li",[e._v("应用层面的性能分析。")]),e._v(" "),v("li",[e._v("binutils的一部分。")]),e._v(" "),v("li",[e._v("在构建/链接时，需要添加gcc -pg选项。")]),e._v(" "),v("li",[e._v("![[Pasted image 20230310222719.png]]")])])])]),e._v(" "),v("p",[e._v("内存debugging：")]),e._v(" "),v("ul",[v("li",[e._v("Valgrind：\n"),v("ul",[v("li",[e._v("用于构建动态分析工具的工具集框架。\n"),v("ul",[v("li",[e._v("检测内存管理和线程bug。")]),e._v(" "),v("li",[e._v("程序性能分析。")])])]),e._v(" "),v("li",[e._v("对程序性能影响较大，但能给出详细的分析。")]),e._v(" "),v("li",[e._v("可以直接在目标板上运行。")]),e._v(" "),v("li",[e._v("工具：\n"),v("ul",[v("li",[e._v("Memcheck：检测内存管理问题。例"),v("code",[e._v("valgrind --leak-check=yes <program>")])]),e._v(" "),v("li",[e._v("Cachegrind：缓存性能分析器，详细模拟CPU中的L1,D1,和L2缓存，因此能够准确指出缓存未命中的代码。")]),e._v(" "),v("li",[e._v("Callgrind：Cachegrind的扩展，提供了关于调用图的额外信息。例"),v("code",[e._v("valgrind --tool=callgrind --dump-instr=yes --simulate-cache=yes --collect-jumps=yes <program>")]),e._v("; "),v("code",[e._v("ls callgrind.out.*")]),e._v("; "),v("code",[e._v("callgrind_annotate callgrind.out.1234")]),e._v("，再使用Kcachegrind可视化性能分析数据。")]),e._v(" "),v("li",[e._v("Massif：通过取程序的堆的快照，进行详细的堆性能分析。")]),e._v(" "),v("li",[e._v("Helgrind：线程debugger，用于查找多线程程序中的数据竞争。查找被多个线程访问，却没有加锁的内存位置。")])])])])]),e._v(" "),v("li",[e._v("资源：\n"),v("ul",[v("li",[e._v("Brendan Gregg "),v("a",{attrs:{href:"https://www.brendangregg.com/systems-performance-2nd-edition-book.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Systems performance"),v("OutboundLink")],1),e._v(" book")]),e._v(" "),v("li",[e._v("Brendan Gregg "),v("a",{attrs:{href:"https://www.brendangregg.com/linuxperf.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Linux Performance"),v("OutboundLink")],1),e._v(" page")]),e._v(" "),v("li",[e._v("Bootlin’s ”Linux debugging, profiling, tracing and performance analysis training” training course and free training materials (250 pages): https://bootlin.com/training/debugging/.")])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);